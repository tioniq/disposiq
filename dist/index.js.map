{"version":3,"sources":["../src/init.ts","../src/utils/noop.ts","../src/action.ts","../src/utils/queue.ts","../src/utils/object-pool.ts","../src/dispose-batch.ts","../src/store.ts","../src/disposable.ts","../src/empty.ts","../src/abort.ts","../src/create.ts","../src/container.ts","../src/bool.ts","../src/event.ts","../src/aliases.ts","../src/exception.ts","../src/utils/exception-handler-manager.ts","../src/safe.ts","../src/is.ts"],"sourcesContent":["type Writable<T> = {\n  -readonly [TKey in keyof T]: T[TKey];\n};\n\ntype WSymbol = Writable<SymbolConstructor>;\n\ninterface ISymbolConstructor {\n  (description?: string | number): symbol;\n}\n\n/**\n * Ensure that the global `Symbol` object has the `dispose` property.\n */\nif (!(\"dispose\" in Symbol)) {\n  const disposeSymbol = (Symbol as ISymbolConstructor)('Symbol.dispose');\n  (Symbol as WSymbol).dispose = disposeSymbol as SymbolConstructor['dispose']\n}\n\n/**\n * Ensure that the global `Symbol` object has the `asyncDispose` property.\n */\nif (!(\"asyncDispose\" in Symbol)) {\n  const asyncDisposeSymbol = (Symbol as ISymbolConstructor)('Symbol.asyncDispose');\n  (Symbol as WSymbol).asyncDispose = asyncDisposeSymbol as SymbolConstructor['asyncDispose']\n}","export const noop = Object.freeze(() => {\n})\n\nexport const noopAsync = Object.freeze(() => Promise.resolve())\n","import {\n  AsyncDisposableAwareCompat,\n  DisposableAwareCompat,\n  DisposeFunc\n} from \"./declarations\";\nimport {noop, noopAsync} from \"./utils/noop\";\n\n/**\n * Represents an action that can be disposed. The action is invoked when the action is disposed.\n * The action is only invoked once.\n * @example\n * const action = new DisposableAction(() => {\n *    console.log(\"disposed\")\n * })\n * action.dispose() // disposed\n * action.dispose() // no-op\n */\nexport class DisposableAction implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: DisposeFunc;\n\n  /**\n   * @internal\n   */\n  private _disposed = false;\n\n  constructor(action: DisposeFunc) {\n    this._action = typeof action === \"function\" ? action : noop;\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a\n   * no-op.\n   * If the action has not been disposed, the action is invoked and the action\n   * is marked as disposed.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    this._action();\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose();\n  }\n}\n\nexport class AsyncDisposableAction implements AsyncDisposableAwareCompat {\n  private readonly _action: () => Promise<void>\n  private _disposed = false\n\n  constructor(action: () => Promise<void>) {\n    this._action = typeof action === \"function\" ? action : noopAsync\n  }\n\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  async dispose() {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    await this._action()\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.asyncDispose](): Promise<void> {\n    return this.dispose()\n  }\n}","export class Node<T> {\n  value: T\n  next: Node<T> | null\n\n  constructor(value: T) {\n    this.value = value\n    this.next = null\n  }\n}\n\nexport class Queue<T> {\n  head: Node<T> | null\n  tail: Node<T> | null\n  length: number\n\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n\n  enqueue(value: T) {\n    const node = new Node(value)\n    if (this.head) {\n      this.tail!.next = node\n      this.tail = node\n    } else {\n      this.head = node\n      this.tail = node\n    }\n    this.length++\n  }\n\n  dequeue(): T | null {\n    const current = this.head\n    if (current === null) {\n      return null\n    }\n    this.head = current.next\n    this.length--\n    return current.value\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0\n  }\n\n  getHead(): T | null {\n    return this.head?.value ?? null\n  }\n\n  getLength(): number {\n    return this.length\n  }\n\n  forEach(consumer: (value: T) => void) {\n    let current = this.head\n    while (current !== null) {\n      consumer(current.value)\n      current = current.next\n    }\n  }\n\n  toArray() {\n    const result: T[] = []\n    let current = this.head\n    while (current !== null) {\n      result.push(current.value)\n      current = current.next\n    }\n    return result\n  }\n\n  clear() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n}\n","import {Queue} from \"./queue\"\n\nexport class ObjectPool<T> {\n  private readonly _scrap: Queue<T>\n  private _size: number\n\n  public constructor(poolSize: number) {\n    this._scrap = new Queue<T>()\n    this._size = poolSize\n  }\n\n  get size(): number {\n    return this._size\n  }\n\n  set size(value: number) {\n    this._size = value\n  }\n\n  get all(): T[] {\n    return this._scrap.toArray()\n  }\n\n  public lift(): T | null {\n    return this._scrap.length > 0 ? this._scrap.dequeue() : null\n  }\n\n  public throw(item: T): T | null {\n    if (this._scrap.length < this._size) {\n      this._scrap.enqueue(item)\n      return null\n    }\n    const recycled = this._scrap.dequeue()\n    this._scrap.enqueue(item)\n    return recycled\n  }\n\n  public clear() {\n    this._scrap.clear()\n  }\n}","import {DisposableLike} from \"./declarations\"\nimport {ObjectPool} from \"./utils/object-pool\"\n\nconst pool = new ObjectPool<DisposableLike[]>(10)\n\n/**\n * Dispose all disposables in the array safely. During the disposal process, the array is safe to modify\n * @param disposables an array of disposables\n */\nexport function disposeAll(disposables: DisposableLike[]) {\n  let size = disposables.length\n  if (size === 0) {\n    return\n  }\n  let holder = pool.lift()\n  if (holder === null) {\n    holder = new Array<DisposableLike>(size)\n  } else {\n    if (holder.length < size) {\n      holder.length = size\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    holder[i] = disposables[i]\n  }\n  disposables.length = 0\n  for (let i = 0; i < size; ++i) {\n    const disposable = holder[i]\n    if (!disposable) {\n      continue\n    }\n    if (typeof disposable === \"function\") {\n      disposable()\n    } else {\n      disposable.dispose()\n    }\n  }\n  holder.fill(undefined!, 0, size)\n  pool.throw(holder)\n}\n\n/**\n * Dispose all disposables in the array unsafely. During the disposal process, the array is not safe to modify\n * @param disposables an array of disposables\n */\nexport function disposeAllUnsafe(disposables: DisposableLike[]) {\n  for (let i = 0; i < disposables.length; ++i) {\n    const disposable = disposables[i]\n    if (!disposable) {\n      continue\n    }\n    if (typeof disposable === \"function\") {\n      disposable()\n    } else {\n      disposable.dispose()\n    }\n  }\n  disposables.length = 0\n}","import {DisposableAwareCompat, DisposableLike, IDisposable, IDisposablesContainer} from \"./declarations\";\nimport {DisposableAction} from \"./action\";\nimport {disposeAll, disposeAllUnsafe} from \"./dispose-batch\";\n\n/**\n * DisposableStore is a container for disposables. It will dispose all added disposables when it is disposed.\n * The store has a disposeCurrent method that will dispose all disposables in the store without disposing the store itself.\n * The store can continue to be used after this method is Â¬called.\n */\nexport class DisposableStore implements IDisposablesContainer, DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _disposables: IDisposable[]\n\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor() {\n    this._disposables = new Array<IDisposable>()\n  }\n\n  /**\n   * Returns true if the object has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Add disposables to the store. If the store has already been disposed, the disposables will be disposed.\n   * @param disposables disposables to add\n   */\n  add(...disposables: DisposableLike[]): void {\n    this.addAll(disposables)\n  }\n\n  /**\n   * Adds disposables to the container. If the container has already been disposed, the disposables will be disposed.\n   * @param disposables Disposables to add.\n   */\n  addAll(disposables: DisposableLike[]): void {\n    if (disposables.length === 0) {\n      return\n    }\n    if (this._disposed) {\n      for (const disposable of disposables) {\n        if (!disposable) {\n          continue\n        }\n        if (typeof disposable === \"function\") {\n          disposable()\n        } else {\n          disposable.dispose()\n        }\n      }\n      return\n    }\n    for (let i = 0; i < disposables.length; i++) {\n      const disposable = disposables[i]\n      if (!disposable) {\n        continue\n      }\n      this._disposables.push(typeof disposable === \"function\" ? new DisposableAction(disposable) : disposable)\n    }\n  }\n\n  /**\n   * Add a disposable to the store. If the store has already been disposed, the disposable will be disposed.\n   * @param disposable a disposable to add\n   * @returns the disposable object\n   */\n  addOne(disposable: DisposableLike): void {\n    if (!disposable) {\n      return\n    }\n    if (this._disposed) {\n      if (typeof disposable === \"function\") {\n        disposable()\n      } else {\n        disposable.dispose()\n      }\n      return\n    }\n    if (typeof disposable === \"function\") {\n      disposable = new DisposableAction(disposable)\n    }\n    this._disposables.push(disposable)\n  }\n\n  /**\n   * Remove a disposable from the store. If the disposable is found and removed, it will be disposed.\n   * @param disposable a disposable to remove\n   * @returns true if the disposable was found and removed\n   */\n  remove(disposable: IDisposable): boolean {\n    const index = this._disposables.indexOf(disposable)\n    if (index === -1) {\n      return false\n    }\n    this._disposables.splice(index, 1)\n    return true\n  }\n\n  /**\n   * Add a timeout to the store. If the store has already been disposed, the timeout will be cleared.\n   * @param callback a callback to call when the timeout expires\n   * @param timeout the number of milliseconds to wait before calling the callback\n   */\n  addTimeout(callback: () => void, timeout: number): void;\n\n  /**\n   * Add a timeout to the store. If the store has already been disposed, the timeout will be cleared.\n   * @param timeout a timeout handle\n   */\n  addTimeout(timeout: ReturnType<typeof setTimeout> | number): void;\n\n  /**\n   * @internal\n   */\n  addTimeout(callbackOrTimeout: (() => void) | ReturnType<typeof setTimeout> | number, timeout?: number | undefined): void {\n    if (typeof callbackOrTimeout === \"function\") {\n      const handle = setTimeout(callbackOrTimeout, timeout)\n      this.add(() => clearTimeout(handle))\n      return\n    }\n    this.add(() => clearTimeout(callbackOrTimeout))\n  }\n\n  /**\n   * Add an interval to the store. If the store has already been disposed, the interval will be cleared.\n   * @param callback a callback to call when the interval expires\n   * @param interval the number of milliseconds to wait between calls to the callback\n   */\n  addInterval(callback: () => void, interval: number): void;\n\n  /**\n   * Add an interval to the store. If the store has already been disposed, the interval will be cleared.\n   * @param interval an interval handle\n   */\n  addInterval(interval: ReturnType<typeof setInterval> | number): void;\n\n  /**\n   * @internal\n   */\n  addInterval(callbackOrInterval: (() => void) | ReturnType<typeof setInterval> | number, interval?: number | undefined): void {\n    if (typeof callbackOrInterval === \"function\") {\n      const handle = setInterval(callbackOrInterval, interval)\n      this.add(() => clearInterval(handle))\n      return\n    }\n    this.add(() => clearInterval(callbackOrInterval))\n  }\n\n  /**\n   * Dispose the store. If the store has already been disposed, this is a no-op.\n   * If the store has not been disposed, all disposables added to the store will be disposed.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    disposeAllUnsafe(this._disposables)\n  }\n\n  /**\n   * Dispose all disposables in the store. The store does not become disposed. The disposables are removed from the\n   * store. The store can continue to be used after this method is called. This method is useful when the store is\n   * used as a temporary container. The store can be disposed later by calling the dispose method. Calling add during\n   * this method will safely add the disposable to the store without disposing it immediately.\n   */\n  disposeCurrent(): void {\n    disposeAll(this._disposables)\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}\n","import {DisposableCompat, IDisposable} from \"./declarations\";\nimport {DisposableStore} from \"./store\";\n\n/**\n * Disposable is a base class for disposables. It will dispose all added disposables when it is disposed.\n */\nexport abstract class Disposable implements DisposableCompat {\n  /**\n   * @internal\n   */\n  private readonly _store = new DisposableStore()\n\n  /**\n   * Returns true if the object has been disposed.\n   */\n  protected get disposed(): boolean {\n    return this._store.disposed\n  }\n\n  /**\n   * Register a disposable object. The object will be disposed when the current object is disposed.\n   * @param t a disposable object\n   * @protected inherited classes should use this method to register disposables\n   * @returns the disposable object\n   */\n  protected register<T extends IDisposable>(t: T): T {\n    this._store.addOne(t)\n    return t\n  }\n\n  /**\n   * Dispose the object. If the object has already been disposed, this is a no-op.\n   * If the object has not been disposed, all disposables added to the object will be disposed.\n   */\n  dispose(): void {\n    this._store.dispose()\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}\n","import {DisposableCompat} from \"./declarations\";\n\nconst emptyDisposableImpl: DisposableCompat = {\n  dispose: function () {\n  },\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose]: function () {\n  }\n}\n\n/**\n * An empty disposable that does nothing when disposed.\n */\nexport const emptyDisposable: DisposableCompat = Object.freeze(emptyDisposableImpl)\n","import {DisposableAwareCompat} from \"./declarations\";\n\n/**\n * Disposable container for AbortController. It will abort the signal when it is disposed.\n */\nexport class AbortDisposable implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private _controller: AbortController\n\n  constructor(controller: AbortController) {\n    this._controller = controller\n  }\n\n  /**\n   * Returns true if the signal is aborted\n   */\n  get disposed(): boolean {\n    return this._controller.signal.aborted\n  }\n\n  /**\n   * Returns the signal of the AbortController\n   */\n  get signal(): AbortSignal {\n    return this._controller.signal\n  }\n\n  /**\n   * Abort the signal\n   */\n  dispose(): void {\n    this._controller.abort()\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}","import {DisposableCompat, DisposableLike, IDisposable} from \"./declarations\";\nimport {emptyDisposable} from \"./empty\";\nimport {AsyncDisposableAction, DisposableAction} from \"./action\";\nimport {AbortDisposable} from \"./abort\";\n\n/**\n * Create a disposable from a disposable like object. The object can be a function, an object with a dispose method,\n * an AbortController, or an object with an internal Symbol.dispose/Symbol.asyncDispose method.\n * @param disposableLike a disposable like object\n * @returns a disposable object. If the input is already a disposable object, it will be returned as is.\n * If the input is a function, it will be wrapped in a DisposableAction object.\n * If the input has internal Symbol.dispose/Symbol.asyncDispose method, it will be wrapped in a DisposableAction object.\n * If the input is an AbortController, it will be wrapped in an AbortDisposable object.\n * If the input is invalid, an empty disposable object will be returned.\n */\nexport function createDisposable(disposableLike: DisposableLike | Disposable | AsyncDisposable | AbortController): IDisposable {\n  if (!disposableLike) {\n    return emptyDisposable\n  }\n  if (typeof disposableLike === 'function') {\n    return new DisposableAction(disposableLike)\n  }\n  if (typeof disposableLike === 'object') {\n    if (\"dispose\" in disposableLike) {\n      return disposableLike\n    }\n    if (Symbol.dispose in disposableLike) {\n      return new DisposableAction(() => {\n        const dispose = disposableLike[Symbol.dispose]\n        dispose()\n      })\n    }\n    if (Symbol.asyncDispose in disposableLike) {\n      return new AsyncDisposableAction(async () => {\n        const dispose = disposableLike[Symbol.asyncDispose]\n        await dispose()\n      })\n    }\n    if (\"unref\" in disposableLike) {\n      // @ts-ignore\n      return new DisposableAction(() => disposableLike.unref())\n    }\n    if (disposableLike instanceof AbortController) {\n      // @ts-ignore\n      return new AbortDisposable(disposableLike)\n    }\n  }\n  // console.warn(\"Invalid disposable\", disposableLike)\n  return emptyDisposable\n}\n\n/**\n * Create a system-compatible disposable from a disposable like object. The object can be a function, an object with a dispose method,\n * an AbortController, or an object with an internal Symbol.dispose/Symbol.asyncDispose method. This function is used to create\n * a disposable object that is compatible with the system's internal disposable object\n * @param disposableLike a disposable like object\n * @returns a disposable object. If the input is already a disposable object with Symbol.dispose/Symbol.asyncDispose, it will be returned as is.\n * If the input is a function, it will be wrapped in a DisposableAction object.\n * If the input has internal Symbol.dispose/Symbol.asyncDispose method, it will be wrapped in a DisposableAction object.\n * If the input is an AbortController, it will be wrapped in an AbortDisposable object.\n * If the input is invalid, an empty disposable object will be returned.\n */\nexport function createDisposableCompat(disposableLike: DisposableLike | Disposable | AsyncDisposable | AbortController): DisposableCompat {\n  if (!disposableLike) {\n    return emptyDisposable\n  }\n  if (typeof disposableLike === 'function') {\n    return new DisposableAction(disposableLike)\n  }\n  if (typeof disposableLike === 'object') {\n    const hasDispose = \"dispose\" in disposableLike\n    const hasSymbolDispose = Symbol.dispose in disposableLike\n    if (hasDispose && hasSymbolDispose) {\n      return disposableLike as DisposableCompat\n    }\n    if (hasDispose) {\n      return new DisposableAction(() => disposableLike.dispose())\n    }\n    if (hasSymbolDispose) {\n      return new DisposableAction(() => disposableLike[Symbol.dispose]())\n    }\n    if (Symbol.asyncDispose in disposableLike) {\n      return new DisposableAction(async () => {\n        disposableLike[Symbol.asyncDispose]()\n      })\n    }\n    if (\"unref\" in disposableLike) {\n      // @ts-ignore\n      return new DisposableAction(() => disposableLike.unref())\n    }\n    if (disposableLike instanceof AbortController) {\n      // @ts-ignore\n      return new AbortDisposable(disposableLike)\n    }\n  }\n  // console.warn(\"Invalid disposable\", disposableLike)\n  return emptyDisposable\n}","import {DisposableAwareCompat, IDisposable} from \"./declarations\";\n\n/**\n * A container for a disposable object. It can be replaced with another disposable object.\n * When disposed, it will dispose the current disposable object and all future disposable objects\n * @example\n * const container = new DisposableContainer()\n * container.set(createDisposable(() => console.log(\"disposed\")))\n * container.dispose() // disposed\n * container.set(createDisposable(() => console.log(\"disposed again\"))) // disposed again\n */\nexport class DisposableContainer implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private _disposable: IDisposable | undefined\n\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor(disposable: IDisposable | undefined = undefined) {\n    this._disposable = disposable\n  }\n\n  /**\n   * Returns true if the container is disposed\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Returns the current disposable object\n   */\n  get disposable(): IDisposable | undefined {\n    return this._disposable\n  }\n\n  /**\n   * Set the new disposable and dispose the old one\n   * @param disposable a new disposable to set\n   */\n  set(disposable: IDisposable): void {\n    if (this._disposed) {\n      disposable.dispose()\n      return\n    }\n    if (this._disposable != undefined) {\n      this._disposable.dispose()\n    }\n    this._disposable = disposable\n  }\n\n  /**\n   * Replace the disposable with a new one. Does not dispose the old one\n   * @param disposable a new disposable to replace the old one\n   */\n  replace(disposable: IDisposable): void {\n    if (this._disposed) {\n      disposable.dispose()\n      return\n    }\n    this._disposable = disposable\n  }\n\n  /**\n   * Dispose the disposable object. All next set or replace calls will dispose the new disposable object\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    if (this._disposable == undefined) {\n      return;\n    }\n    this._disposable.dispose()\n    this._disposable = undefined\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}","import {DisposableAwareCompat} from \"./declarations\";\n\n/**\n * Class of a disposable that can be checked for disposal status.\n */\nexport class BoolDisposable implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor(disposed: boolean = false) {\n    this._disposed = disposed\n  }\n\n  /**\n   * Returns true if the disposable is disposed\n   */\n  get disposed() {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the object\n   */\n  dispose() {\n    this._disposed = true\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose]() {\n    this.dispose()\n  }\n}","import {DisposableAwareCompat} from \"./declarations\";\nimport {DisposableAction} from \"./action\";\n\ninterface EventEmitterLike {\n  on<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n\n  off<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n\n  once?<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n}\n\n/**\n * Create a disposable from an event emitter. The disposable will remove the listener from the emitter when disposed.\n * @param emitter an event emitter\n * @param event the event name\n * @param listener the event listener\n * @returns a disposable object\n * @remarks All my trials to infer event name list and listener arguments failed. I had to use (string | symbol) for\n * event name and any[] for listener args. I'm not sure if it's possible to infer them for now.\n * If you can do it, please let me know and let's talk about it))\n */\nexport function disposableFromEvent<K extends string | symbol>(emitter: EventEmitterLike, event: K, listener: (...args: any[]) => void): DisposableAwareCompat {\n  emitter.on(event, listener)\n  return new DisposableAction(() => {\n    emitter.off(event, listener)\n  })\n}\n\n/**\n * Create a disposable from an event emitter. The disposable will remove the listener from the emitter when disposed.\n * The listener will only be called once.\n * @param emitter an event emitter\n * @param event the event name\n * @param listener the event listener\n * @returns a disposable object\n */\nexport function disposableFromEventOnce<K extends string | symbol>(emitter: EventEmitterLike, event: K, listener: (...args: any[]) => void): DisposableAwareCompat {\n  emitter.once(event, listener)\n  return new DisposableAction(() => {\n    emitter.off(event, listener)\n  })\n}\n","import {DisposableStore} from \"./store\";\nimport {DisposableContainer} from \"./container\";\nimport {BoolDisposable} from \"./bool\";\nimport {disposeAll} from \"./dispose-batch\";\nimport {disposableFromEvent, disposableFromEventOnce} from \"./event\";\nimport {createDisposable, createDisposableCompat} from \"./create\";\n\nexport const CompositeDisposable = DisposableStore\nexport const SerialDisposable = DisposableContainer\nexport const BooleanDisposable = BoolDisposable\nexport const disposeAllSafe = disposeAll\nexport const on = disposableFromEvent\nexport const once = disposableFromEventOnce\nexport const toDisposable = createDisposable\nexport const toDisposableCompat = createDisposableCompat\n","/**\n * Exception class for scenarios where an exception needs to be thrown when an object is disposed\n */\nexport class ObjectDisposedException extends Error {\n  constructor(message?: string | undefined) {\n    super(message || \"Object disposed\");\n  }\n}","import {noop} from \"./noop\";\n\nexport type ExceptionHandler = (error: Error) => void\n\n/**\n * Exception handler manager\n */\nexport class ExceptionHandlerManager {\n  /**\n   * @internal\n   */\n  private readonly _defaultHandler: ExceptionHandler\n\n  /**\n   * @internal\n   */\n  private _handler: ExceptionHandler\n\n  /**\n   * Create a new ExceptionHandlerManager with the default handler\n   * @param defaultHandler the default handler. If not provided, the default handler will be a no-op\n   */\n  constructor(defaultHandler?: ExceptionHandler | null) {\n    this._handler = typeof defaultHandler === \"function\" ? defaultHandler : noop\n  }\n\n  /**\n   * Get the handler for the manager\n   */\n  get handler(): ExceptionHandler {\n    return this._handler\n  }\n\n  /**\n   * Set the handler for the manager\n   */\n  set handler(value: ExceptionHandler | undefined | null) {\n    this._handler = typeof value === \"function\" ? value : this._defaultHandler\n  }\n\n  /**\n   * Reset the handler to the default handler\n   */\n  reset() {\n    this._handler = this._defaultHandler\n  }\n\n  /**\n   * Handle an exception\n   * @param error the exception to handle\n   */\n  handle(error: Error): void {\n    this._handler(error)\n  }\n\n  /**\n   * Handle an exception\n   * @param error the exception to handle\n   */\n  handleAny(error: any): void {\n    if (!(error instanceof Error)) {\n      error = new Error(error)\n    }\n    this._handler(error)\n  }\n\n  /**\n   * Handle an exception safely\n   * @param error the exception to handle\n   */\n  handleSafe(error: Error): void {\n    try {\n      this.handle(error)\n    } catch (e) {\n    }\n  }\n\n  /**\n   * Handle an exception safely\n   * @param error the exception to handle\n   */\n  handleAnySafe(error: any): void {\n    try {\n      this.handleAny(error)\n    } catch (e) {\n    }\n  }\n}","import {AsyncDisposableAwareCompat, DisposableAwareCompat} from \"./declarations\";\nimport {ExceptionHandlerManager} from \"./utils/exception-handler-manager\";\nimport {noop, noopAsync} from \"./utils/noop\";\n\nexport const safeDisposableExceptionHandlerManager = new ExceptionHandlerManager()\n\n/**\n * Represents a safe action that can be disposed. The action is invoked when the action is disposed.\n */\nexport class SafeActionDisposable implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: () => void\n\n  /**\n   * @internal\n   */\n  private _disposed = false\n\n  constructor(action?: () => void) {\n    this._action = typeof action === \"function\" ? action : noop\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a no-op.\n   */\n  dispose() {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    try {\n      this._action()\n    } catch (e) {\n      safeDisposableExceptionHandlerManager.handleAny(e)\n    }\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose();\n  }\n}\n\n/**\n * Represents a safe async action that can be disposed. The action is invoked when the action is disposed.\n */\nexport class SafeAsyncActionDisposable implements AsyncDisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: () => Promise<void>\n\n  /**\n   * @internal\n   */\n  private _disposed = false\n\n  constructor(action: () => Promise<void>) {\n    this._action = typeof action === \"function\" ? action : noopAsync\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a no-op.\n   */\n  async dispose(): Promise<void> {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    try {\n      await this._action()\n    } catch (e) {\n      safeDisposableExceptionHandlerManager.handleAny(e)\n    }\n  }\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.asyncDispose](): Promise<void> {\n    return this.dispose()\n  }\n}","import {AsyncDisposableCompat, DisposableCompat, DisposableLike, IDisposable} from \"./declarations\";\n\n/**\n * Check if the value is a disposable object. It means it has a `dispose` method.\n */\nexport function isDisposable(value: any): value is IDisposable {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\"\n}\n\n/**\n * Check if the value is a disposable object or a function. It means it has a `dispose` method, or it is a function.\n */\nexport function isDisposableLike(value: any): value is DisposableLike {\n  return typeof value === \"function\" || (typeof value === \"object\" && value !== null && typeof value.dispose === \"function\")\n}\n\n/**\n * Check if the value is a disposable object with a `dispose` method and an internal `Symbol.dispose` method.\n */\nexport function isDisposableCompat(value: any): value is DisposableCompat {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\" && typeof value[Symbol.dispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.asyncDispose` method.\n */\nexport function isAsyncDisposableCompat(value: any): value is AsyncDisposableCompat {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\" && typeof value[Symbol.asyncDispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.dispose` method.\n */\nexport function isSystemDisposable(value: any): value is Disposable {\n  return typeof value === \"object\" && value !== null && typeof value[Symbol.dispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.asyncDispose` method.\n */\nexport function isSystemAsyncDisposable(value: any): value is AsyncDisposable {\n  return typeof value === \"object\" && value !== null && typeof value[Symbol.asyncDispose] === \"function\"\n}"],"mappings":"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","names":["noop","noopAsync","DisposableAction","action","noop","AsyncDisposableAction","noopAsync","__async","Node","value","Queue","node","current","_a","_b","consumer","result","ObjectPool","poolSize","Queue","value","item","recycled","pool","ObjectPool","disposeAll","disposables","size","holder","i","disposable","disposeAllUnsafe","DisposableStore","disposables","disposable","i","DisposableAction","index","callbackOrTimeout","timeout","handle","callbackOrInterval","interval","disposeAllUnsafe","disposeAll","Disposable","DisposableStore","t","emptyDisposableImpl","emptyDisposable","AbortDisposable","controller","createDisposable","disposableLike","emptyDisposable","DisposableAction","dispose","AsyncDisposableAction","__async","AbortDisposable","createDisposableCompat","hasDispose","hasSymbolDispose","DisposableContainer","disposable","BoolDisposable","disposed","disposableFromEvent","emitter","event","listener","DisposableAction","disposableFromEventOnce","CompositeDisposable","DisposableStore","SerialDisposable","DisposableContainer","BooleanDisposable","BoolDisposable","disposeAllSafe","disposeAll","on","disposableFromEvent","once","disposableFromEventOnce","toDisposable","createDisposable","toDisposableCompat","createDisposableCompat","ObjectDisposedException","message","ExceptionHandlerManager","defaultHandler","noop","value","error","e","safeDisposableExceptionHandlerManager","ExceptionHandlerManager","SafeActionDisposable","action","noop","SafeAsyncActionDisposable","noopAsync","__async","isDisposable","value","isDisposableLike","isDisposableCompat","isAsyncDisposableCompat","isSystemDisposable","isSystemAsyncDisposable"]}