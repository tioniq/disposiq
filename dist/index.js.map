{"version":3,"sources":["../src/init.ts","../src/disposiq.ts","../src/abort.ts","../src/utils/noop.ts","../src/action.ts","../src/utils/queue.ts","../src/utils/object-pool.ts","../src/dispose-batch.ts","../src/exception.ts","../src/store.ts","../src/container.ts","../src/bool.ts","../src/event.ts","../src/empty.ts","../src/create.ts","../src/disposable.ts","../src/extensions.ts","../src/is.ts","../src/utils/exception-handler-manager.ts","../src/safe.ts","../src/using.ts"],"sourcesContent":["type Writable<T> = {\n  -readonly [TKey in keyof T]: T[TKey];\n};\n\ntype WSymbol = Writable<SymbolConstructor>;\n\ninterface ISymbolConstructor {\n  (description?: string | number): symbol;\n}\n\n/**\n * Ensure that the global `Symbol` object has the `dispose` property.\n */\nif (!(\"dispose\" in Symbol)) {\n  const disposeSymbol = (Symbol as ISymbolConstructor)('Symbol.dispose');\n  (Symbol as WSymbol).dispose = disposeSymbol as SymbolConstructor['dispose']\n}\n\n/**\n * Ensure that the global `Symbol` object has the `asyncDispose` property.\n */\nif (!(\"asyncDispose\" in Symbol)) {\n  const asyncDisposeSymbol = (Symbol as ISymbolConstructor)('Symbol.asyncDispose');\n  (Symbol as WSymbol).asyncDispose = asyncDisposeSymbol as SymbolConstructor['asyncDispose']\n}","import {DisposableCompat, IDisposablesContainer} from \"./declarations\";\n\n/**\n * Disposiq is a base class for disposables. The only reason is to have ability to extend it with additional functionality.\n */\nexport abstract class Disposiq implements DisposableCompat {\n  abstract dispose(): void;\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.dispose](): void {\n    this.dispose();\n  }\n}\n\nexport abstract class AsyncDisposiq extends Disposiq {\n  abstract dispose(): Promise<void>;\n\n  /**\n   * Support for the internal Disposable API\n   */\n  [Symbol.asyncDispose](): Promise<void> {\n    return this.dispose();\n  }\n}\n\nexport interface Disposiq {\n  disposeWith(container: IDisposablesContainer): void;\n}\n","import {DisposableAwareCompat} from \"./declarations\";\nimport {Disposiq} from \"./disposiq\";\n\n/**\n * Disposable container for AbortController. It will abort the signal when it is disposed.\n */\nexport class AbortDisposable extends Disposiq implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _controller: AbortController\n\n  constructor(controller: AbortController) {\n    super()\n    this._controller = controller\n  }\n\n  /**\n   * Returns true if the signal is aborted\n   */\n  get disposed(): boolean {\n    return this._controller.signal.aborted\n  }\n\n  /**\n   * Returns the signal of the AbortController\n   */\n  get signal(): AbortSignal {\n    return this._controller.signal\n  }\n\n  /**\n   * Abort the signal\n   */\n  dispose(): void {\n    this._controller.abort()\n  }\n}","export const noop = Object.freeze(() => {\n})\n\nexport const noopAsync = Object.freeze(() => Promise.resolve())\n","import {\n  AsyncDisposableAwareCompat,\n  DisposableAwareCompat,\n  DisposeFunc\n} from \"./declarations\";\nimport {noop, noopAsync} from \"./utils/noop\";\nimport {AsyncDisposiq, Disposiq} from \"./disposiq\";\n\n/**\n * Represents an action that can be disposed. The action is invoked when the action is disposed.\n * The action is only invoked once.\n * @example\n * const action = new DisposableAction(() => {\n *    console.log(\"disposed\")\n * })\n * action.dispose() // disposed\n * action.dispose() // no-op\n */\nexport class DisposableAction extends Disposiq implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: DisposeFunc\n\n  /**\n   * @internal\n   */\n  private _disposed = false\n\n  constructor(action: DisposeFunc) {\n    super()\n    this._action = typeof action === \"function\" ? action : noop\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a\n   * no-op.\n   * If the action has not been disposed, the action is invoked and the action\n   * is marked as disposed.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    this._action()\n  }\n}\n\n/**\n * Represents an async action that can be disposed. The action is invoked when the action is disposed.\n * The action is only invoked once.\n * @example\n * const action = new AsyncDisposableAction(async () => {\n *    console.log(\"disposed\")\n * })\n * await action.dispose() // disposed\n * await action.dispose() // no-op\n */\nexport class AsyncDisposableAction extends AsyncDisposiq implements AsyncDisposableAwareCompat {\n  private readonly _action: () => Promise<void>\n  private _disposed = false\n\n  constructor(action: () => Promise<void>) {\n    super()\n    this._action = typeof action === \"function\" ? action : noopAsync\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a\n   * no-op.\n   * If the action has not been disposed, the action is invoked and the action\n   * is marked as disposed.\n   */\n  async dispose(): Promise<void> {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    await this._action()\n  }\n}","export class Node<T> {\n  value: T\n  next: Node<T> | null\n\n  constructor(value: T) {\n    this.value = value\n    this.next = null\n  }\n}\n\nexport class Queue<T> {\n  head: Node<T> | null\n  tail: Node<T> | null\n  length: number\n\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n\n  enqueue(value: T) {\n    const node = new Node(value)\n    if (this.head) {\n      this.tail!.next = node\n      this.tail = node\n    } else {\n      this.head = node\n      this.tail = node\n    }\n    this.length++\n  }\n\n  dequeue(): T | null {\n    const current = this.head\n    if (current === null) {\n      return null\n    }\n    this.head = current.next\n    this.length--\n    return current.value\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0\n  }\n\n  getHead(): T | null {\n    return this.head?.value ?? null\n  }\n\n  getLength(): number {\n    return this.length\n  }\n\n  forEach(consumer: (value: T) => void) {\n    let current = this.head\n    while (current !== null) {\n      consumer(current.value)\n      current = current.next\n    }\n  }\n\n  toArray() {\n    const result: T[] = []\n    let current = this.head\n    while (current !== null) {\n      result.push(current.value)\n      current = current.next\n    }\n    return result\n  }\n\n  clear() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n}\n","import {Queue} from \"./queue\"\n\nexport class ObjectPool<T> {\n  private readonly _scrap: Queue<T>\n  private _size: number\n\n  public constructor(poolSize: number) {\n    this._scrap = new Queue<T>()\n    this._size = poolSize\n  }\n\n  get size(): number {\n    return this._size\n  }\n\n  set size(value: number) {\n    this._size = value\n  }\n\n  get all(): T[] {\n    return this._scrap.toArray()\n  }\n\n  get full(): boolean {\n    return this._scrap.length === this._size\n  }\n\n  public lift(): T | null {\n    return this._scrap.length > 0 ? this._scrap.dequeue() : null\n  }\n\n  public throw(item: T): T | null {\n    if (this._scrap.length < this._size) {\n      this._scrap.enqueue(item)\n      return null\n    }\n    if (this._size === 0) {\n      return item\n    }\n    const recycled = this._scrap.dequeue()\n    this._scrap.enqueue(item)\n    return recycled\n  }\n\n  public clear() {\n    this._scrap.clear()\n  }\n}","import {DisposableLike} from \"./declarations\"\nimport {ObjectPool} from \"./utils/object-pool\"\n\nconst pool = new ObjectPool<DisposableLike[]>(10)\n\n/**\n * Dispose all disposables in the array safely. During the disposal process, the array is safe to modify\n * @param disposables an array of disposables\n */\nexport function disposeAll(disposables: DisposableLike[]) {\n  let size = disposables.length\n  if (size === 0) {\n    return\n  }\n  let holder = pool.lift()\n  if (holder === null) {\n    holder = new Array<DisposableLike>(size)\n  } else {\n    if (holder.length < size) {\n      holder.length = size\n    }\n  }\n  for (let i = 0; i < size; i++) {\n    holder[i] = disposables[i]\n  }\n  disposables.length = 0\n  for (let i = 0; i < size; ++i) {\n    const disposable = holder[i]\n    if (!disposable) {\n      continue\n    }\n    if (typeof disposable === \"function\") {\n      disposable()\n    } else {\n      disposable.dispose()\n    }\n  }\n  holder.fill(undefined!, 0, size)\n  if (pool.full) {\n    pool.size *= 2\n  }\n  pool.throw(holder)\n}\n\n/**\n * Dispose all disposables in the array unsafely. During the disposal process, the array is not safe to modify\n * @param disposables an array of disposables\n */\nexport function disposeAllUnsafe(disposables: DisposableLike[]) {\n  for (let i = 0; i < disposables.length; ++i) {\n    const disposable = disposables[i]\n    if (!disposable) {\n      continue\n    }\n    if (typeof disposable === \"function\") {\n      disposable()\n    } else {\n      disposable.dispose()\n    }\n  }\n  disposables.length = 0\n}","/**\n * Exception class for scenarios where an exception needs to be thrown when an object is disposed\n */\nexport class ObjectDisposedException extends Error {\n  constructor(message?: string | undefined) {\n    super(message || \"Object disposed\")\n  }\n}","import {DisposableAwareCompat, DisposableLike, IDisposable, IDisposablesContainer} from \"./declarations\";\nimport {DisposableAction} from \"./action\";\nimport {disposeAll, disposeAllUnsafe} from \"./dispose-batch\";\nimport {Disposiq} from \"./disposiq\";\nimport {ObjectDisposedException} from \"./exception\";\n\n/**\n * DisposableStore is a container for disposables. It will dispose all added disposables when it is disposed.\n * The store has a disposeCurrent method that will dispose all disposables in the store without disposing the store itself.\n * The store can continue to be used after this method is called.\n */\nexport class DisposableStore extends Disposiq implements IDisposablesContainer, DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _disposables: IDisposable[]\n\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor() {\n    super()\n    this._disposables = new Array<IDisposable>()\n  }\n\n  /**\n   * Returns true if the object has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Add disposables to the store. If the store has already been disposed, the disposables will be disposed.\n   * @param disposables disposables to add\n   */\n  add(...disposables: DisposableLike[]): void {\n    this.addAll(disposables)\n  }\n\n  /**\n   * Adds disposables to the container. If the container has already been disposed, the disposables will be disposed.\n   * @param disposables Disposables to add.\n   */\n  addAll(disposables: DisposableLike[]): void {\n    if (!disposables || disposables.length === 0) {\n      return\n    }\n    if (this._disposed) {\n      for (const disposable of disposables) {\n        if (!disposable) {\n          continue\n        }\n        if (typeof disposable === \"function\") {\n          disposable()\n        } else {\n          disposable.dispose()\n        }\n      }\n      return\n    }\n    for (let i = 0; i < disposables.length; i++) {\n      const disposable = disposables[i]\n      if (!disposable) {\n        continue\n      }\n      this._disposables.push(typeof disposable === \"function\" ? new DisposableAction(disposable) : disposable)\n    }\n  }\n\n  /**\n   * Add a disposable to the store. If the store has already been disposed, the disposable will be disposed.\n   * @param disposable a disposable to add\n   * @returns the disposable object\n   */\n  addOne(disposable: DisposableLike): void {\n    if (!disposable) {\n      return\n    }\n    if (this._disposed) {\n      if (typeof disposable === \"function\") {\n        disposable()\n      } else {\n        disposable.dispose()\n      }\n      return\n    }\n    if (typeof disposable === \"function\") {\n      disposable = new DisposableAction(disposable)\n    }\n    this._disposables.push(disposable)\n  }\n\n  /**\n   * Remove a disposable from the store. If the disposable is found and removed, it will be disposed.\n   * @param disposable a disposable to remove\n   * @returns true if the disposable was found and removed\n   */\n  remove(disposable: IDisposable): boolean {\n    const index = this._disposables.indexOf(disposable)\n    if (index === -1) {\n      return false\n    }\n    this._disposables.splice(index, 1)\n    return true\n  }\n\n  /**\n   * Add a timeout to the store. If the store has already been disposed, the timeout will be cleared.\n   * @param callback a callback to call when the timeout expires\n   * @param timeout the number of milliseconds to wait before calling the callback\n   */\n  addTimeout(callback: () => void, timeout: number): void;\n\n  /**\n   * Add a timeout to the store. If the store has already been disposed, the timeout will be cleared.\n   * @param timeout a timeout handle\n   */\n  addTimeout(timeout: ReturnType<typeof setTimeout> | number): void;\n\n  /**\n   * @internal\n   */\n  addTimeout(callbackOrTimeout: (() => void) | ReturnType<typeof setTimeout> | number, timeout?: number | undefined): void {\n    if (typeof callbackOrTimeout === \"function\") {\n      const handle = setTimeout(callbackOrTimeout, timeout)\n      this.add(() => clearTimeout(handle))\n      return\n    }\n    this.add(() => clearTimeout(callbackOrTimeout))\n  }\n\n  /**\n   * Add an interval to the store. If the store has already been disposed, the interval will be cleared.\n   * @param callback a callback to call when the interval expires\n   * @param interval the number of milliseconds to wait between calls to the callback\n   */\n  addInterval(callback: () => void, interval: number): void;\n\n  /**\n   * Add an interval to the store. If the store has already been disposed, the interval will be cleared.\n   * @param interval an interval handle\n   */\n  addInterval(interval: ReturnType<typeof setInterval> | number): void;\n\n  /**\n   * @internal\n   */\n  addInterval(callbackOrInterval: (() => void) | ReturnType<typeof setInterval> | number, interval?: number | undefined): void {\n    if (typeof callbackOrInterval === \"function\") {\n      const handle = setInterval(callbackOrInterval, interval)\n      this.add(() => clearInterval(handle))\n      return\n    }\n    this.add(() => clearInterval(callbackOrInterval))\n  }\n\n  /**\n   * Throw an exception if the object has been disposed.\n   * @param message the message to include in the exception\n   */\n  throwIfDisposed(message?: string): void {\n    if (this._disposed) {\n      throw new ObjectDisposedException(message)\n    }\n  }\n\n  /**\n   * Dispose the store. If the store has already been disposed, this is a no-op.\n   * If the store has not been disposed, all disposables added to the store will be disposed.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    disposeAllUnsafe(this._disposables)\n  }\n\n  /**\n   * Dispose all disposables in the store. The store does not become disposed. The disposables are removed from the\n   * store. The store can continue to be used after this method is called. This method is useful when the store is\n   * used as a temporary container. The store can be disposed later by calling the dispose method. Calling add during\n   * this method will safely add the disposable to the store without disposing it immediately.\n   */\n  disposeCurrent(): void {\n    disposeAll(this._disposables)\n  }\n\n  /**\n   * Create a disposable store from an array of values. The values are mapped to disposables using the provided\n   * mapper function.\n   * @param values an array of values\n   * @param mapper a function that maps a value to a disposable\n   */\n  static from<T>(values: T[], mapper: (value: T) => DisposableLike): DisposableStore\n\n  /**\n   * Create a disposable store from an array of disposables.\n   * @param disposables an array of disposables\n   * @returns a disposable store containing the disposables\n   */\n  static from(disposables: DisposableLike[]): DisposableStore\n\n  static from<T>(disposables: DisposableLike[] | T[], mapper?: (value: T) => DisposableLike): DisposableStore {\n    if (typeof mapper === \"function\") {\n      const store = new DisposableStore()\n      store.addAll((disposables as T[]).map(mapper))\n      return store\n    }\n    const store = new DisposableStore()\n    store.addAll(disposables as DisposableLike[])\n    return store\n  }\n}\n","import {DisposableAwareCompat, IDisposable} from \"./declarations\";\nimport {Disposiq} from \"./disposiq\";\n\n/**\n * A container for a disposable object. It can be replaced with another disposable object.\n * When disposed, it will dispose the current disposable object and all future disposable objects\n * @example\n * const container = new DisposableContainer()\n * container.set(createDisposable(() => console.log(\"disposed\")))\n * container.dispose() // disposed\n * container.set(createDisposable(() => console.log(\"disposed again\"))) // disposed again\n */\nexport class DisposableContainer extends Disposiq implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private _disposable: IDisposable | undefined\n\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor(disposable: IDisposable | undefined = undefined) {\n    super()\n    this._disposable = disposable\n  }\n\n  /**\n   * Returns true if the container is disposed\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Returns the current disposable object\n   */\n  get disposable(): IDisposable | undefined {\n    return this._disposable\n  }\n\n  /**\n   * Set the new disposable and dispose the old one\n   * @param disposable a new disposable to set\n   */\n  set(disposable: IDisposable): void {\n    if (this._disposed) {\n      disposable.dispose()\n      return\n    }\n    const oldDisposable = this._disposable\n    this._disposable = disposable\n    if (oldDisposable != undefined) {\n      oldDisposable.dispose()\n    }\n  }\n\n  /**\n   * Replace the disposable with a new one. Does not dispose the old one\n   * @param disposable a new disposable to replace the old one\n   */\n  replace(disposable: IDisposable): void {\n    if (this._disposed) {\n      disposable.dispose()\n      return\n    }\n    this._disposable = disposable\n  }\n\n  /**\n   * Dispose only the current disposable object without affecting the container's state.\n   */\n  disposeCurrent(): void {\n    const disposable = this._disposable\n    if (disposable != undefined) {\n      this._disposable = undefined;\n      disposable.dispose();\n    }\n  }\n\n  /**\n   * Dispose the disposable object. All next set or replace calls will dispose the new disposable object\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    if (this._disposable == undefined) {\n      return;\n    }\n    this._disposable.dispose()\n    this._disposable = undefined\n  }\n}","import {DisposableAwareCompat} from \"./declarations\";\nimport {Disposiq} from \"./disposiq\";\n\n/**\n * Class of a disposable that can be checked for disposal status.\n */\nexport class BoolDisposable extends Disposiq implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private _disposed: boolean = false\n\n  constructor(disposed: boolean = false) {\n    super()\n    this._disposed = disposed\n  }\n\n  /**\n   * Returns true if the disposable is disposed\n   */\n  get disposed() {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the object\n   */\n  dispose() {\n    this._disposed = true\n  }\n}","import {DisposableAwareCompat} from \"./declarations\";\nimport {DisposableAction} from \"./action\";\n\ninterface EventEmitterLike {\n  on<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n\n  off<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n\n  once?<K extends string | symbol>(event: K, listener: (...args: any[]) => void): any\n}\n\n/**\n * Create a disposable from an event emitter. The disposable will remove the listener from the emitter when disposed.\n * @param emitter an event emitter\n * @param event the event name\n * @param listener the event listener\n * @returns a disposable object\n * @remarks All my trials to infer event name list and listener arguments failed. I had to use (string | symbol) for\n * event name and any[] for listener args. I'm not sure if it's possible to infer them for now.\n * If you can do it, please let me know and let's talk about it))\n */\nexport function disposableFromEvent<K extends string | symbol>(emitter: EventEmitterLike, event: K, listener: (...args: any[]) => void): DisposableAwareCompat {\n  emitter.on(event, listener)\n  return new DisposableAction(() => {\n    emitter.off(event, listener)\n  })\n}\n\n/**\n * Create a disposable from an event emitter. The disposable will remove the listener from the emitter when disposed.\n * The listener will only be called once.\n * @param emitter an event emitter\n * @param event the event name\n * @param listener the event listener\n * @returns a disposable object\n */\nexport function disposableFromEventOnce<K extends string | symbol>(emitter: EventEmitterLike, event: K, listener: (...args: any[]) => void): DisposableAwareCompat {\n  emitter.once(event, listener)\n  return new DisposableAction(() => {\n    emitter.off(event, listener)\n  })\n}\n","import {AsyncDisposableCompat, DisposableCompat} from \"./declarations\";\nimport {AsyncDisposiq, Disposiq} from \"./disposiq\";\n\nconst emptyPromise = Promise.resolve()\n\nclass EmptyDisposable extends AsyncDisposiq implements DisposableCompat, AsyncDisposableCompat {\n  dispose(): Promise<void> {\n    return emptyPromise\n  }\n\n  override [Symbol.dispose](): void {\n  }\n\n  override [Symbol.asyncDispose](): Promise<void> {\n    return emptyPromise\n  }\n}\n\nconst emptyDisposableImpl = new EmptyDisposable()\n\n/**\n * An empty disposable that does nothing when disposed.\n */\nexport const emptyDisposable: Disposiq & AsyncDisposiq & DisposableCompat & AsyncDisposableCompat = Object.freeze(emptyDisposableImpl)\n","import {DisposableCompat, DisposableLike, IDisposable} from \"./declarations\";\nimport {emptyDisposable} from \"./empty\";\nimport {AsyncDisposableAction, DisposableAction} from \"./action\";\nimport {AbortDisposable} from \"./abort\";\nimport {Disposiq} from \"./disposiq\";\n\n/**\n * Create a disposable from a disposable like object. The object can be a function, an object with a dispose method,\n * an AbortController, or an object with an internal Symbol.dispose/Symbol.asyncDispose method.\n * @param disposableLike a disposable like object\n * @returns a disposable object. If the input is already a disposable object, it will be returned as is.\n * If the input is a function, it will be wrapped in a DisposableAction object.\n * If the input has internal Symbol.dispose/Symbol.asyncDispose method, it will be wrapped in a DisposableAction object.\n * If the input is an AbortController, it will be wrapped in an AbortDisposable object.\n * If the input is invalid, an empty disposable object will be returned.\n */\nexport function createDisposable(disposableLike: DisposableLike | Disposable | AsyncDisposable | AbortController): IDisposable {\n  if (!disposableLike) {\n    return emptyDisposable\n  }\n  if (typeof disposableLike === 'function') {\n    return new DisposableAction(disposableLike)\n  }\n  if (typeof disposableLike !== 'object') {\n    return emptyDisposable\n  }\n  if (\"dispose\" in disposableLike) {\n    return disposableLike\n  }\n  if (Symbol.dispose in disposableLike) {\n    return new DisposableAction(() => {\n      disposableLike[Symbol.dispose]()\n    })\n  }\n  if (Symbol.asyncDispose in disposableLike) {\n    return new AsyncDisposableAction(async () => {\n      await disposableLike[Symbol.asyncDispose]()\n    })\n  }\n  if (\"unref\" in disposableLike) {\n    // @ts-ignore\n    return new DisposableAction(() => disposableLike.unref())\n  }\n  if (disposableLike instanceof AbortController) {\n    // @ts-ignore\n    return new AbortDisposable(disposableLike)\n  }\n  return emptyDisposable\n}\n\n/**\n * Create a system-compatible disposable from a disposable like object. The object can be a function, an object with a dispose method,\n * an AbortController, or an object with an internal Symbol.dispose/Symbol.asyncDispose method. This function is used to create\n * a disposable object that is compatible with the system's internal disposable object\n * @param disposableLike a disposable like object\n * @returns a disposable object. If the input is already a disposable object with Symbol.dispose/Symbol.asyncDispose, it will be returned as is.\n * If the input is a function, it will be wrapped in a DisposableAction object.\n * If the input has internal Symbol.dispose/Symbol.asyncDispose method, it will be wrapped in a DisposableAction object.\n * If the input is an AbortController, it will be wrapped in an AbortDisposable object.\n * If the input is invalid, an empty disposable object will be returned.\n */\nexport function createDisposableCompat(disposableLike: DisposableLike | Disposable | AsyncDisposable | AbortController): DisposableCompat {\n  if (!disposableLike) {\n    return emptyDisposable\n  }\n  if (typeof disposableLike === 'function') {\n    return new DisposableAction(disposableLike)\n  }\n  if (typeof disposableLike !== 'object') {\n    return emptyDisposable\n  }\n  const hasDispose = \"dispose\" in disposableLike\n  const hasSymbolDispose = Symbol.dispose in disposableLike\n  if (hasDispose && hasSymbolDispose) {\n    return disposableLike as DisposableCompat\n  }\n  if (hasDispose) {\n    return new DisposableAction(() => disposableLike.dispose())\n  }\n  if (hasSymbolDispose) {\n    return new DisposableAction(() => disposableLike[Symbol.dispose]())\n  }\n  if (Symbol.asyncDispose in disposableLike) {\n    return new DisposableAction(async () => {\n      disposableLike[Symbol.asyncDispose]()\n    })\n  }\n  if (\"unref\" in disposableLike) {\n    // @ts-ignore\n    return new DisposableAction(() => disposableLike.unref())\n  }\n  if (disposableLike instanceof AbortController) {\n    // @ts-ignore\n    return new AbortDisposable(disposableLike)\n  }\n  return emptyDisposable\n}\n\n/**\n * Create a Disposiq-inherited object from a disposable like object. The object can be a function, an object with a\n * dispose method, an AbortController, or an object with an internal Symbol.dispose/Symbol.asyncDispose method. This\n * function is used to create a Disposiq instance that is compatible with all extensions of Disposiq\n * @param disposableLike a disposable like object\n * @returns a Disposiq object. If the input is already a Disposiq object, it will be returned as is.\n */\nexport function createDisposiq(disposableLike: DisposableLike | Disposable | AsyncDisposable | AbortController): Disposiq {\n  if (!disposableLike) {\n    return emptyDisposable\n  }\n  if (disposableLike instanceof Disposiq) {\n    return disposableLike\n  }\n  if (typeof disposableLike === 'function') {\n    return new DisposableAction(disposableLike)\n  }\n  if (typeof disposableLike !== 'object') {\n    return emptyDisposable\n  }\n  const hasDispose = \"dispose\" in disposableLike && typeof disposableLike.dispose === \"function\"\n  const hasSymbolDispose = Symbol.dispose in disposableLike\n  if (hasDispose && hasSymbolDispose) {\n    return new class extends Disposiq {\n      dispose() {\n        disposableLike.dispose()\n      }\n\n      override [Symbol.dispose](): void {\n        (disposableLike[Symbol.dispose] as () => void)()\n      }\n    }\n  }\n  if (hasDispose) {\n    return new DisposableAction(() => disposableLike.dispose())\n  }\n  if (hasSymbolDispose) {\n    return new DisposableAction(() => disposableLike[Symbol.dispose]())\n  }\n  if (Symbol.asyncDispose in disposableLike) {\n    return new AsyncDisposableAction(async () => {\n      await disposableLike[Symbol.asyncDispose]()\n    })\n  }\n  if (\"unref\" in disposableLike) {\n    // @ts-ignore\n    return new DisposableAction(() => disposableLike.unref())\n  }\n  if (disposableLike instanceof AbortController) {\n    // @ts-ignore\n    return new AbortDisposable(disposableLike)\n  }\n  return emptyDisposable\n}\n","import {DisposableCompat, DisposableLike, IDisposable} from \"./declarations\";\nimport {DisposableStore} from \"./store\";\nimport {Disposiq} from \"./disposiq\";\n\n/**\n * Disposable is a base class for disposables. It will dispose all added disposables when it is disposed.\n */\nexport abstract class Disposable extends Disposiq implements DisposableCompat {\n  /**\n   * @internal\n   */\n  private readonly _store = new DisposableStore()\n\n  /**\n   * Returns true if the object has been disposed.\n   */\n  protected get disposed(): boolean {\n    return this._store.disposed\n  }\n\n  /**\n   * Register a disposable object. The object will be disposed when the current object is disposed.\n   * @param t a disposable object\n   * @protected inherited classes should use this method to register disposables\n   * @returns the disposable object\n   */\n  protected register<T extends IDisposable>(t: T): T {\n    this._store.addOne(t)\n    return t\n  }\n\n  /**\n   * Throw an exception if the object has been disposed.\n   * @param message the message to include in the exception\n   * @protected inherited classes can use this method to throw an exception if the object has been disposed\n   */\n  protected throwIfDisposed(message?: string): void {\n    this._store.throwIfDisposed(message)\n  }\n\n  /**\n   * Add disposables to the store. If the store has already been disposed, the disposables will be disposed.\n   * @param disposable a disposable to add\n   */\n  addDisposable(disposable: DisposableLike): void {\n    this._store.addOne(disposable)\n  }\n\n  /**\n   * Add disposables to the store. If the store has already been disposed, the disposables will be disposed.\n   * @param disposables disposables to add\n   */\n  addDisposables(...disposables: DisposableLike[]): void {\n    this._store.addAll(disposables)\n  }\n\n  /**\n   * Dispose the object. If the object has already been disposed, this is a no-op.\n   * If the object has not been disposed, all disposables added to the object will be disposed.\n   */\n  dispose(): void {\n    this._store.dispose()\n  }\n}\n","import {Disposiq} from \"./disposiq\";\nimport {IDisposablesContainer} from \"./declarations\";\n\nDisposiq.prototype.disposeWith = function (this: Disposiq, container: IDisposablesContainer): void {\n  return container.add(this)\n}","import {AsyncDisposableCompat, DisposableCompat, DisposableLike, IDisposable} from \"./declarations\";\n\n/**\n * Check if the value is a disposable object. It means it has a `dispose` method.\n */\nexport function isDisposable(value: any): value is IDisposable {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\"\n}\n\n/**\n * Check if the value is a disposable object or a function. It means it has a `dispose` method, or it is a function.\n */\nexport function isDisposableLike(value: any): value is DisposableLike {\n  return typeof value === \"function\" || (typeof value === \"object\" && value !== null && typeof value.dispose === \"function\")\n}\n\n/**\n * Check if the value is a disposable object with a `dispose` method and an internal `Symbol.dispose` method.\n */\nexport function isDisposableCompat(value: any): value is DisposableCompat {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\" && typeof value[Symbol.dispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.asyncDispose` method.\n */\nexport function isAsyncDisposableCompat(value: any): value is AsyncDisposableCompat {\n  return typeof value === \"object\" && value !== null && typeof value.dispose === \"function\" && typeof value[Symbol.asyncDispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.dispose` method.\n */\nexport function isSystemDisposable(value: any): value is Disposable {\n  return typeof value === \"object\" && value !== null && typeof value[Symbol.dispose] === \"function\"\n}\n\n/**\n * Check if the value is a disposable object with an internal `Symbol.asyncDispose` method.\n */\nexport function isSystemAsyncDisposable(value: any): value is AsyncDisposable {\n  return typeof value === \"object\" && value !== null && typeof value[Symbol.asyncDispose] === \"function\"\n}","import {noop} from \"./noop\";\n\nexport type ExceptionHandler = (error: any) => void\n\n/**\n * Exception handler manager\n */\nexport class ExceptionHandlerManager {\n  /**\n   * @internal\n   */\n  private readonly _defaultHandler: ExceptionHandler\n\n  /**\n   * @internal\n   */\n  private _handler: ExceptionHandler\n\n  /**\n   * Create a new ExceptionHandlerManager with the default handler\n   * @param defaultHandler the default handler. If not provided, the default handler will be a no-op\n   */\n  constructor(defaultHandler?: ExceptionHandler | null) {\n    this._handler = this._defaultHandler = typeof defaultHandler === \"function\" ? defaultHandler : noop\n  }\n\n  /**\n   * Get the handler for the manager\n   */\n  get handler(): ExceptionHandler {\n    return this._handler\n  }\n\n  /**\n   * Set the handler for the manager\n   */\n  set handler(value: ExceptionHandler | undefined | null) {\n    this._handler = typeof value === \"function\" ? value : this._defaultHandler\n  }\n\n  /**\n   * Reset the handler to the default handler\n   */\n  reset() {\n    this._handler = this._defaultHandler\n  }\n\n  /**\n   * Handle an exception\n   * @param error the exception to handle\n   */\n  handle(error: any): void {\n    this._handler(error)\n  }\n\n  /**\n   * Handle an exception safely\n   * @param error the exception to handle\n   */\n  handleSafe(error: Error): void {\n    try {\n      this.handle(error)\n    } catch (e) {\n    }\n  }\n}","import {AsyncDisposableAwareCompat, DisposableAwareCompat} from \"./declarations\";\nimport {ExceptionHandlerManager} from \"./utils/exception-handler-manager\";\nimport {noop, noopAsync} from \"./utils/noop\";\nimport {AsyncDisposiq, Disposiq} from \"./disposiq\";\n\nexport const safeDisposableExceptionHandlerManager = new ExceptionHandlerManager()\n\n/**\n * Represents a safe action that can be disposed. The action is invoked when the action is disposed.\n */\nexport class SafeActionDisposable extends Disposiq implements DisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: () => void\n\n  /**\n   * @internal\n   */\n  private _disposed = false\n\n  constructor(action: () => void) {\n    super()\n    this._action = typeof action === \"function\" ? action : noop\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a no-op.\n   */\n  dispose() {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    try {\n      this._action()\n    } catch (e) {\n      safeDisposableExceptionHandlerManager.handle(e)\n    }\n  }\n}\n\n/**\n * Represents a safe async action that can be disposed. The action is invoked when the action is disposed.\n */\nexport class SafeAsyncActionDisposable extends AsyncDisposiq implements AsyncDisposableAwareCompat {\n  /**\n   * @internal\n   */\n  private readonly _action: () => Promise<void>\n\n  /**\n   * @internal\n   */\n  private _disposed = false\n\n  constructor(action: () => Promise<void>) {\n    super()\n    this._action = typeof action === \"function\" ? action : noopAsync\n  }\n\n  /**\n   * Returns true if the action has been disposed.\n   */\n  get disposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Dispose the action. If the action has already been disposed, this is a no-op.\n   */\n  async dispose(): Promise<void> {\n    if (this._disposed) {\n      return\n    }\n    this._disposed = true\n    try {\n      await this._action()\n    } catch (e) {\n      safeDisposableExceptionHandlerManager.handle(e)\n    }\n  }\n}","import {IAsyncDisposable, IDisposable} from \"./declarations\";\n\nexport function using<T extends IDisposable, R>(resource: T, action: (resource: T) => R): R\n\nexport function using<T extends IDisposable | IAsyncDisposable, R>(resource: T, action: (resource: T) => Promise<R>): Promise<R>\n\nexport function using<T extends IDisposable | IAsyncDisposable, R>(resource: T, action: (resource: T) => R | Promise<R>): R | Promise<R> {\n  let result: R | Promise<R>\n  try {\n    result = action(resource)\n  } catch (e) {\n    return runDispose(resource, () => {\n      throw e\n    })\n  }\n  if (result instanceof Promise) {\n    return result.then(r => runDispose(resource, () => r))\n      .catch(e => runDispose(resource, () => {\n        throw e\n      }))\n  }\n  return runDispose(resource, () => result)\n}\n\nfunction runDispose<R>(disposable: IDisposable | IAsyncDisposable, action: () => R): R | Promise<R> {\n  const disposeResult = disposable.dispose()\n  if (disposeResult instanceof Promise) {\n    return disposeResult.then(action)\n  }\n  return action()\n}"],"mappings":"6MAaM,YAAa,SAEhB,OAAmB,QADG,OAA8B,gBAAgB,GAOjE,iBAAkB,SAErB,OAAmB,aADQ,OAA8B,qBAAqB,GCjB1E,IAAeA,EAAf,KAAoD,CAMzD,CAAC,OAAO,OAAO,GAAU,CACvB,KAAK,QAAQ,CACf,CACF,EAEsBC,EAAf,cAAqCD,CAAS,CAMnD,CAAC,OAAO,YAAY,GAAmB,CACrC,OAAO,KAAK,QAAQ,CACtB,CACF,ECnBO,IAAME,EAAN,cAA8BC,CAA0C,CAM7E,YAAYC,EAA6B,CACvC,MAAM,EACN,KAAK,YAAcA,CACrB,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,YAAY,OAAO,OACjC,CAKA,IAAI,QAAsB,CACxB,OAAO,KAAK,YAAY,MAC1B,CAKA,SAAgB,CACd,KAAK,YAAY,MAAM,CACzB,CACF,ECrCO,IAAMC,EAAO,OAAO,OAAO,IAAM,CACxC,CAAC,EAEYC,EAAY,OAAO,OAAO,IAAM,QAAQ,QAAQ,CAAC,ECevD,IAAMC,EAAN,cAA+BC,CAA0C,CAW9E,YAAYC,EAAqB,CAC/B,MAAM,EAHR,KAAQ,UAAY,GAIlB,KAAK,QAAU,OAAOA,GAAW,WAAaA,EAASC,CACzD,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAQA,SAAgB,CACV,KAAK,YAGT,KAAK,UAAY,GACjB,KAAK,QAAQ,EACf,CACF,EAYaC,EAAN,cAAoCC,CAAoD,CAI7F,YAAYH,EAA6B,CACvC,MAAM,EAHR,KAAQ,UAAY,GAIlB,KAAK,QAAU,OAAOA,GAAW,WAAaA,EAASI,CACzD,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAQM,SAAyB,QAAAC,EAAA,sBACzB,KAAK,YAGT,KAAK,UAAY,GACjB,MAAM,KAAK,QAAQ,EACrB,GACF,EC/FO,IAAMC,EAAN,KAAc,CAInB,YAAYC,EAAU,CACpB,KAAK,MAAQA,EACb,KAAK,KAAO,IACd,CACF,EAEaC,EAAN,KAAe,CAKpB,aAAc,CACZ,KAAK,KAAO,KACZ,KAAK,KAAO,KACZ,KAAK,OAAS,CAChB,CAEA,QAAQD,EAAU,CAChB,IAAME,EAAO,IAAIH,EAAKC,CAAK,EACvB,KAAK,MACP,KAAK,KAAM,KAAOE,EAClB,KAAK,KAAOA,IAEZ,KAAK,KAAOA,EACZ,KAAK,KAAOA,GAEd,KAAK,QACP,CAEA,SAAoB,CAClB,IAAMC,EAAU,KAAK,KACrB,OAAIA,IAAY,KACP,MAET,KAAK,KAAOA,EAAQ,KACpB,KAAK,SACEA,EAAQ,MACjB,CAEA,SAAmB,CACjB,OAAO,KAAK,SAAW,CACzB,CAEA,SAAoB,CA/CtB,IAAAC,EAAAC,EAgDI,OAAOA,GAAAD,EAAA,KAAK,OAAL,YAAAA,EAAW,QAAX,KAAAC,EAAoB,IAC7B,CAEA,WAAoB,CAClB,OAAO,KAAK,MACd,CAEA,QAAQC,EAA8B,CACpC,IAAIH,EAAU,KAAK,KACnB,KAAOA,IAAY,MACjBG,EAASH,EAAQ,KAAK,EACtBA,EAAUA,EAAQ,IAEtB,CAEA,SAAU,CACR,IAAMI,EAAc,CAAC,EACjBJ,EAAU,KAAK,KACnB,KAAOA,IAAY,MACjBI,EAAO,KAAKJ,EAAQ,KAAK,EACzBA,EAAUA,EAAQ,KAEpB,OAAOI,CACT,CAEA,OAAQ,CACN,KAAK,KAAO,KACZ,KAAK,KAAO,KACZ,KAAK,OAAS,CAChB,CACF,EC5EO,IAAMC,EAAN,KAAoB,CAIlB,YAAYC,EAAkB,CACnC,KAAK,OAAS,IAAIC,EAClB,KAAK,MAAQD,CACf,CAEA,IAAI,MAAe,CACjB,OAAO,KAAK,KACd,CAEA,IAAI,KAAKE,EAAe,CACtB,KAAK,MAAQA,CACf,CAEA,IAAI,KAAW,CACb,OAAO,KAAK,OAAO,QAAQ,CAC7B,CAEA,IAAI,MAAgB,CAClB,OAAO,KAAK,OAAO,SAAW,KAAK,KACrC,CAEO,MAAiB,CACtB,OAAO,KAAK,OAAO,OAAS,EAAI,KAAK,OAAO,QAAQ,EAAI,IAC1D,CAEO,MAAMC,EAAmB,CAC9B,GAAI,KAAK,OAAO,OAAS,KAAK,MAC5B,YAAK,OAAO,QAAQA,CAAI,EACjB,KAET,GAAI,KAAK,QAAU,EACjB,OAAOA,EAET,IAAMC,EAAW,KAAK,OAAO,QAAQ,EACrC,YAAK,OAAO,QAAQD,CAAI,EACjBC,CACT,CAEO,OAAQ,CACb,KAAK,OAAO,MAAM,CACpB,CACF,EC5CA,IAAMC,EAAO,IAAIC,EAA6B,EAAE,EAMzC,SAASC,EAAWC,EAA+B,CACxD,IAAIC,EAAOD,EAAY,OACvB,GAAIC,IAAS,EACX,OAEF,IAAIC,EAASL,EAAK,KAAK,EACnBK,IAAW,KACbA,EAAS,IAAI,MAAsBD,CAAI,EAEnCC,EAAO,OAASD,IAClBC,EAAO,OAASD,GAGpB,QAASE,EAAI,EAAGA,EAAIF,EAAME,IACxBD,EAAOC,CAAC,EAAIH,EAAYG,CAAC,EAE3BH,EAAY,OAAS,EACrB,QAASG,EAAI,EAAGA,EAAIF,EAAM,EAAEE,EAAG,CAC7B,IAAMC,EAAaF,EAAOC,CAAC,EACtBC,IAGD,OAAOA,GAAe,WACxBA,EAAW,EAEXA,EAAW,QAAQ,EAEvB,CACAF,EAAO,KAAK,OAAY,EAAGD,CAAI,EAC3BJ,EAAK,OACPA,EAAK,MAAQ,GAEfA,EAAK,MAAMK,CAAM,CACnB,CAMO,SAASG,EAAiBL,EAA+B,CAC9D,QAASG,EAAI,EAAGA,EAAIH,EAAY,OAAQ,EAAEG,EAAG,CAC3C,IAAMC,EAAaJ,EAAYG,CAAC,EAC3BC,IAGD,OAAOA,GAAe,WACxBA,EAAW,EAEXA,EAAW,QAAQ,EAEvB,CACAJ,EAAY,OAAS,CACvB,CC1DO,IAAMM,EAAN,cAAsC,KAAM,CACjD,YAAYC,EAA8B,CACxC,MAAMA,GAAW,iBAAiB,CACpC,CACF,ECIO,IAAMC,EAAN,MAAMC,UAAwBC,CAAiE,CAWpG,aAAc,CACZ,MAAM,EAHR,KAAQ,UAAqB,GAI3B,KAAK,aAAe,IAAI,KAC1B,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAMA,OAAOC,EAAqC,CAC1C,KAAK,OAAOA,CAAW,CACzB,CAMA,OAAOA,EAAqC,CAC1C,GAAI,GAACA,GAAeA,EAAY,SAAW,GAG3C,IAAI,KAAK,UAAW,CAClB,QAAWC,KAAcD,EAClBC,IAGD,OAAOA,GAAe,WACxBA,EAAW,EAEXA,EAAW,QAAQ,GAGvB,MACF,CACA,QAASC,EAAI,EAAGA,EAAIF,EAAY,OAAQE,IAAK,CAC3C,IAAMD,EAAaD,EAAYE,CAAC,EAC3BD,GAGL,KAAK,aAAa,KAAK,OAAOA,GAAe,WAAa,IAAIE,EAAiBF,CAAU,EAAIA,CAAU,CACzG,EACF,CAOA,OAAOA,EAAkC,CACvC,GAAKA,EAGL,IAAI,KAAK,UAAW,CACd,OAAOA,GAAe,WACxBA,EAAW,EAEXA,EAAW,QAAQ,EAErB,MACF,CACI,OAAOA,GAAe,aACxBA,EAAa,IAAIE,EAAiBF,CAAU,GAE9C,KAAK,aAAa,KAAKA,CAAU,EACnC,CAOA,OAAOA,EAAkC,CACvC,IAAMG,EAAQ,KAAK,aAAa,QAAQH,CAAU,EAClD,OAAIG,IAAU,GACL,IAET,KAAK,aAAa,OAAOA,EAAO,CAAC,EAC1B,GACT,CAkBA,WAAWC,EAA0EC,EAAoC,CACvH,GAAI,OAAOD,GAAsB,WAAY,CAC3C,IAAME,EAAS,WAAWF,EAAmBC,CAAO,EACpD,KAAK,IAAI,IAAM,aAAaC,CAAM,CAAC,EACnC,MACF,CACA,KAAK,IAAI,IAAM,aAAaF,CAAiB,CAAC,CAChD,CAkBA,YAAYG,EAA4EC,EAAqC,CAC3H,GAAI,OAAOD,GAAuB,WAAY,CAC5C,IAAMD,EAAS,YAAYC,EAAoBC,CAAQ,EACvD,KAAK,IAAI,IAAM,cAAcF,CAAM,CAAC,EACpC,MACF,CACA,KAAK,IAAI,IAAM,cAAcC,CAAkB,CAAC,CAClD,CAMA,gBAAgBE,EAAwB,CACtC,GAAI,KAAK,UACP,MAAM,IAAIC,EAAwBD,CAAO,CAE7C,CAMA,SAAgB,CACV,KAAK,YAGT,KAAK,UAAY,GACjBE,EAAiB,KAAK,YAAY,EACpC,CAQA,gBAAuB,CACrBC,EAAW,KAAK,YAAY,CAC9B,CAiBA,OAAO,KAAQb,EAAqCc,EAAwD,CAC1G,GAAI,OAAOA,GAAW,WAAY,CAChC,IAAMC,EAAQ,IAAIjB,EAClB,OAAAiB,EAAM,OAAQf,EAAoB,IAAIc,CAAM,CAAC,EACtCC,CACT,CACA,IAAMA,EAAQ,IAAIjB,EAClB,OAAAiB,EAAM,OAAOf,CAA+B,EACrCe,CACT,CACF,EC5MO,IAAMC,EAAN,cAAkCC,CAA0C,CAWjF,YAAYC,EAAsC,OAAW,CAC3D,MAAM,EAHR,KAAQ,UAAqB,GAI3B,KAAK,YAAcA,CACrB,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAKA,IAAI,YAAsC,CACxC,OAAO,KAAK,WACd,CAMA,IAAIA,EAA+B,CACjC,GAAI,KAAK,UAAW,CAClBA,EAAW,QAAQ,EACnB,MACF,CACA,IAAMC,EAAgB,KAAK,YAC3B,KAAK,YAAcD,EACfC,GAAiB,MACnBA,EAAc,QAAQ,CAE1B,CAMA,QAAQD,EAA+B,CACrC,GAAI,KAAK,UAAW,CAClBA,EAAW,QAAQ,EACnB,MACF,CACA,KAAK,YAAcA,CACrB,CAKA,gBAAuB,CACrB,IAAMA,EAAa,KAAK,YACpBA,GAAc,OAChB,KAAK,YAAc,OACnBA,EAAW,QAAQ,EAEvB,CAKA,SAAgB,CACV,KAAK,YAGT,KAAK,UAAY,GACb,KAAK,aAAe,OAGxB,KAAK,YAAY,QAAQ,EACzB,KAAK,YAAc,QACrB,CACF,ECzFO,IAAME,EAAN,cAA6BC,CAA0C,CAM5E,YAAYC,EAAoB,GAAO,CACrC,MAAM,EAHR,KAAQ,UAAqB,GAI3B,KAAK,UAAYA,CACnB,CAKA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CAKA,SAAU,CACR,KAAK,UAAY,EACnB,CACF,ECTO,SAASC,EAA+CC,EAA2BC,EAAUC,EAA2D,CAC7J,OAAAF,EAAQ,GAAGC,EAAOC,CAAQ,EACnB,IAAIC,EAAiB,IAAM,CAChCH,EAAQ,IAAIC,EAAOC,CAAQ,CAC7B,CAAC,CACH,CAUO,SAASE,EAAmDJ,EAA2BC,EAAUC,EAA2D,CACjK,OAAAF,EAAQ,KAAKC,EAAOC,CAAQ,EACrB,IAAIC,EAAiB,IAAM,CAChCH,EAAQ,IAAIC,EAAOC,CAAQ,CAC7B,CAAC,CACH,CCtCA,IAAMG,EAAe,QAAQ,QAAQ,EAE/BC,EAAN,cAA8BC,CAAiE,CAC7F,SAAyB,CACvB,OAAOF,CACT,CAEA,CAAU,OAAO,OAAO,GAAU,CAClC,CAEA,CAAU,OAAO,YAAY,GAAmB,CAC9C,OAAOA,CACT,CACF,EAEMG,EAAsB,IAAIF,EAKnBG,EAAuF,OAAO,OAAOD,CAAmB,ECP9H,SAASE,EAAiBC,EAA8F,CAC7H,OAAKA,EAGD,OAAOA,GAAmB,WACrB,IAAIC,EAAiBD,CAAc,EAExC,OAAOA,GAAmB,SACrBE,EAEL,YAAaF,EACRA,EAEL,OAAO,WAAWA,EACb,IAAIC,EAAiB,IAAM,CAChCD,EAAe,OAAO,OAAO,EAAE,CACjC,CAAC,EAEC,OAAO,gBAAgBA,EAClB,IAAIG,EAAsB,IAAYC,EAAA,sBAC3C,MAAMJ,EAAe,OAAO,YAAY,EAAE,CAC5C,EAAC,EAEC,UAAWA,EAEN,IAAIC,EAAiB,IAAMD,EAAe,MAAM,CAAC,EAEtDA,aAA0B,gBAErB,IAAIK,EAAgBL,CAAc,EAEpCE,EA7BEA,CA8BX,CAaO,SAASI,EAAuBN,EAAmG,CACxI,GAAI,CAACA,EACH,OAAOE,EAET,GAAI,OAAOF,GAAmB,WAC5B,OAAO,IAAIC,EAAiBD,CAAc,EAE5C,GAAI,OAAOA,GAAmB,SAC5B,OAAOE,EAET,IAAMK,EAAa,YAAaP,EAC1BQ,EAAmB,OAAO,WAAWR,EAC3C,OAAIO,GAAcC,EACTR,EAELO,EACK,IAAIN,EAAiB,IAAMD,EAAe,QAAQ,CAAC,EAExDQ,EACK,IAAIP,EAAiB,IAAMD,EAAe,OAAO,OAAO,EAAE,CAAC,EAEhE,OAAO,gBAAgBA,EAClB,IAAIC,EAAiB,IAAYG,EAAA,sBACtCJ,EAAe,OAAO,YAAY,EAAE,CACtC,EAAC,EAEC,UAAWA,EAEN,IAAIC,EAAiB,IAAMD,EAAe,MAAM,CAAC,EAEtDA,aAA0B,gBAErB,IAAIK,EAAgBL,CAAc,EAEpCE,CACT,CASO,SAASO,EAAeT,EAA2F,CACxH,GAAI,CAACA,EACH,OAAOE,EAET,GAAIF,aAA0BU,EAC5B,OAAOV,EAET,GAAI,OAAOA,GAAmB,WAC5B,OAAO,IAAIC,EAAiBD,CAAc,EAE5C,GAAI,OAAOA,GAAmB,SAC5B,OAAOE,EAET,IAAMK,EAAa,YAAaP,GAAkB,OAAOA,EAAe,SAAY,WAC9EQ,EAAmB,OAAO,WAAWR,EAC3C,OAAIO,GAAcC,EACT,IAAI,cAAcE,CAAS,CAChC,SAAU,CACRV,EAAe,QAAQ,CACzB,CAEA,CAAU,OAAO,OAAO,GAAU,CAC/BA,EAAe,OAAO,OAAO,EAAiB,CACjD,CACF,EAEEO,EACK,IAAIN,EAAiB,IAAMD,EAAe,QAAQ,CAAC,EAExDQ,EACK,IAAIP,EAAiB,IAAMD,EAAe,OAAO,OAAO,EAAE,CAAC,EAEhE,OAAO,gBAAgBA,EAClB,IAAIG,EAAsB,IAAYC,EAAA,sBAC3C,MAAMJ,EAAe,OAAO,YAAY,EAAE,CAC5C,EAAC,EAEC,UAAWA,EAEN,IAAIC,EAAiB,IAAMD,EAAe,MAAM,CAAC,EAEtDA,aAA0B,gBAErB,IAAIK,EAAgBL,CAAc,EAEpCE,CACT,CChJO,IAAeS,EAAf,cAAkCC,CAAqC,CAAvE,kCAIL,KAAiB,OAAS,IAAIC,EAK9B,IAAc,UAAoB,CAChC,OAAO,KAAK,OAAO,QACrB,CAQU,SAAgCC,EAAS,CACjD,YAAK,OAAO,OAAOA,CAAC,EACbA,CACT,CAOU,gBAAgBC,EAAwB,CAChD,KAAK,OAAO,gBAAgBA,CAAO,CACrC,CAMA,cAAcC,EAAkC,CAC9C,KAAK,OAAO,OAAOA,CAAU,CAC/B,CAMA,kBAAkBC,EAAqC,CACrD,KAAK,OAAO,OAAOA,CAAW,CAChC,CAMA,SAAgB,CACd,KAAK,OAAO,QAAQ,CACtB,CACF,EC5DAC,EAAS,UAAU,YAAc,SAA0BC,EAAwC,CACjG,OAAOA,EAAU,IAAI,IAAI,CAC3B,ECAO,SAASC,GAAaC,EAAkC,CAC7D,OAAO,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,SAAY,UACjF,CAKO,SAASC,GAAiBD,EAAqC,CACpE,OAAO,OAAOA,GAAU,YAAe,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,SAAY,UACjH,CAKO,SAASE,GAAmBF,EAAuC,CACxE,OAAO,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,SAAY,YAAc,OAAOA,EAAM,OAAO,OAAO,GAAM,UAChI,CAKO,SAASG,GAAwBH,EAA4C,CAClF,OAAO,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,SAAY,YAAc,OAAOA,EAAM,OAAO,YAAY,GAAM,UACrI,CAKO,SAASI,GAAmBJ,EAAiC,CAClE,OAAO,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,OAAO,OAAO,GAAM,UACzF,CAKO,SAASK,GAAwBL,EAAsC,CAC5E,OAAO,OAAOA,GAAU,UAAYA,IAAU,MAAQ,OAAOA,EAAM,OAAO,YAAY,GAAM,UAC9F,CCnCO,IAAMM,EAAN,KAA8B,CAenC,YAAYC,EAA0C,CACpD,KAAK,SAAW,KAAK,gBAAkB,OAAOA,GAAmB,WAAaA,EAAiBC,CACjG,CAKA,IAAI,SAA4B,CAC9B,OAAO,KAAK,QACd,CAKA,IAAI,QAAQC,EAA4C,CACtD,KAAK,SAAW,OAAOA,GAAU,WAAaA,EAAQ,KAAK,eAC7D,CAKA,OAAQ,CACN,KAAK,SAAW,KAAK,eACvB,CAMA,OAAOC,EAAkB,CACvB,KAAK,SAASA,CAAK,CACrB,CAMA,WAAWA,EAAoB,CAC7B,GAAI,CACF,KAAK,OAAOA,CAAK,CACnB,OAAS,EAAG,CACZ,CACF,CACF,EC5DO,IAAMC,EAAwC,IAAIC,EAK5CC,EAAN,cAAmCC,CAA0C,CAWlF,YAAYC,EAAoB,CAC9B,MAAM,EAHR,KAAQ,UAAY,GAIlB,KAAK,QAAU,OAAOA,GAAW,WAAaA,EAASC,CACzD,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAKA,SAAU,CACR,GAAI,MAAK,UAGT,MAAK,UAAY,GACjB,GAAI,CACF,KAAK,QAAQ,CACf,OAAS,EAAG,CACVL,EAAsC,OAAO,CAAC,CAChD,EACF,CACF,EAKaM,EAAN,cAAwCC,CAAoD,CAWjG,YAAYH,EAA6B,CACvC,MAAM,EAHR,KAAQ,UAAY,GAIlB,KAAK,QAAU,OAAOA,GAAW,WAAaA,EAASI,CACzD,CAKA,IAAI,UAAoB,CACtB,OAAO,KAAK,SACd,CAKM,SAAyB,QAAAC,EAAA,sBAC7B,GAAI,MAAK,UAGT,MAAK,UAAY,GACjB,GAAI,CACF,MAAM,KAAK,QAAQ,CACrB,OAAS,EAAG,CACVT,EAAsC,OAAO,CAAC,CAChD,EACF,GACF,ECnFO,SAASU,GAAmDC,EAAaC,EAAyD,CACvI,IAAIC,EACJ,GAAI,CACFA,EAASD,EAAOD,CAAQ,CAC1B,OAASG,EAAG,CACV,OAAOC,EAAWJ,EAAU,IAAM,CAChC,MAAMG,CACR,CAAC,CACH,CACA,OAAID,aAAkB,QACbA,EAAO,KAAKG,GAAKD,EAAWJ,EAAU,IAAMK,CAAC,CAAC,EAClD,MAAMF,GAAKC,EAAWJ,EAAU,IAAM,CACrC,MAAMG,CACR,CAAC,CAAC,EAECC,EAAWJ,EAAU,IAAME,CAAM,CAC1C,CAEA,SAASE,EAAcE,EAA4CL,EAAiC,CAClG,IAAMM,EAAgBD,EAAW,QAAQ,EACzC,OAAIC,aAAyB,QACpBA,EAAc,KAAKN,CAAM,EAE3BA,EAAO,CAChB","names":["Disposiq","AsyncDisposiq","AbortDisposable","Disposiq","controller","noop","noopAsync","DisposableAction","Disposiq","action","noop","AsyncDisposableAction","AsyncDisposiq","noopAsync","__async","Node","value","Queue","node","current","_a","_b","consumer","result","ObjectPool","poolSize","Queue","value","item","recycled","pool","ObjectPool","disposeAll","disposables","size","holder","i","disposable","disposeAllUnsafe","ObjectDisposedException","message","DisposableStore","_DisposableStore","Disposiq","disposables","disposable","i","DisposableAction","index","callbackOrTimeout","timeout","handle","callbackOrInterval","interval","message","ObjectDisposedException","disposeAllUnsafe","disposeAll","mapper","store","DisposableContainer","Disposiq","disposable","oldDisposable","BoolDisposable","Disposiq","disposed","disposableFromEvent","emitter","event","listener","DisposableAction","disposableFromEventOnce","emptyPromise","EmptyDisposable","AsyncDisposiq","emptyDisposableImpl","emptyDisposable","createDisposable","disposableLike","DisposableAction","emptyDisposable","AsyncDisposableAction","__async","AbortDisposable","createDisposableCompat","hasDispose","hasSymbolDispose","createDisposiq","Disposiq","Disposable","Disposiq","DisposableStore","t","message","disposable","disposables","Disposiq","container","isDisposable","value","isDisposableLike","isDisposableCompat","isAsyncDisposableCompat","isSystemDisposable","isSystemAsyncDisposable","ExceptionHandlerManager","defaultHandler","noop","value","error","safeDisposableExceptionHandlerManager","ExceptionHandlerManager","SafeActionDisposable","Disposiq","action","noop","SafeAsyncActionDisposable","AsyncDisposiq","noopAsync","__async","using","resource","action","result","e","runDispose","r","disposable","disposeResult"]}